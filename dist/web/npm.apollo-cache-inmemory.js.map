{"version":3,"sources":["webpack:///./node_modules/apollo-cache-inmemory/lib/bundle.esm.js"],"names":["haveWarned","shouldWarn","answer","HeuristicFragmentMatcher","prototype","ensureReady","Promise","resolve","canBypassInit","match","idValue","typeCondition","context","obj","store","get","id","isRootQuery","_a","__typename","hasOwn","IntrospectionFragmentMatcher","options","introspectionQueryResultData","this","possibleTypesMap","parseIntrospectionResult","isReady","bind","implementingTypes","indexOf","introspectionResultData","typeMap","__schema","types","forEach","type","kind","name","possibleTypes","map","implementingType","Object","hasOwnProperty","DepTrackingCache","data","_this","create","depend","dataId","disposable","makeCacheKey","toObject","set","value","dirty","delete","call","clear","replace","newData","keys","defaultNormalizedCacheFactory","seed","StoreReader","_b","_c","cacheKeyRoot","_d","freezeResults","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","query","rootValue","contextValue","variableValues","fragmentMatcher","lookup","JSON","stringify","selectionSet","execContext","field","array","readQueryFromStore","diffQueryAgainstStore","returnPartialData","result","variables","previousResult","rootId","fragmentMatcherFunction","config","queryDefinition","dataIdFromObject","cacheRedirects","execResult","generated","typename","hasMissingFields","missing","length","info","tolerable","complete","defaultFragmentMatcher","mainDefinition","fragments","fragmentMap","finalResult","objectsToMerge","object","handleMissing","push","apply","selections","selection","fieldResult","executeField","fragment","fragmentExecResult","readStoreResult","fieldName","args","resultKey","directives","storeKeyName","fieldValue","resolver","getCacheKey","storeObj","json","readStoreResolver","Array","isArray","combineExecResults","assertSelectionSetForIdValue","execResults","_i","arguments","pop","childResult","item","ObjectCache","WriteError","_super","Error","StoreWriter","writeQueryToStore","writeResultToStore","document","operationDefinition","writeSelectionSetToStore","processedData","e","error","enhancedError","message","stack","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","some","directive","matches","undefined","fakeContext","storeValue","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","cache","real","madeChanges","key","realValue","newRealValue","index","itemDataId","defaultConfig","_id","addTypename","resultCaching","hasOwn$1","OptimisticCacheLayer","optimisticId","parent","transaction","InMemoryCache","watches","Set","typenameDocumentCache","Map","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","c","optimistic","restore","extract","read","transformDocument","write","broadcastWatches","diff","watch","add","evict","reset","removeOptimistic","idToRemove","toReapply","removedCount","layer","layer_1","performTransaction","recordOptimisticTransaction","callback"],"mappings":"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","file":"npm.apollo-cache-inmemory.js","sourcesContent":["import { __assign, __extends } from 'tslib';\nimport { ApolloCache } from 'apollo-cache';\nimport { isTest, getQueryDefinition, assign, getDefaultValues, isEqual, getMainDefinition, getFragmentDefinitions, createFragmentMap, shouldInclude, isField, resultKeyNameFromField, isInlineFragment, mergeDeepArray, argumentsObjectFromField, getDirectiveInfoFromField, maybeDeepFreeze, isIdValue, getStoreKeyName, toIdValue, isJsonValue, canUseWeakMap, getOperationDefinition, isProduction, storeKeyNameFromField, addTypenameToDocument } from 'apollo-utilities';\nimport { wrap, KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nvar haveWarned = false;\nfunction shouldWarn() {\n    var answer = !haveWarned;\n    if (!isTest()) {\n        haveWarned = true;\n    }\n    return answer;\n}\nvar HeuristicFragmentMatcher = (function () {\n    function HeuristicFragmentMatcher() {\n    }\n    HeuristicFragmentMatcher.prototype.ensureReady = function () {\n        return Promise.resolve();\n    };\n    HeuristicFragmentMatcher.prototype.canBypassInit = function () {\n        return true;\n    };\n    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n        if (!__typename) {\n            if (shouldWarn()) {\n                process.env.NODE_ENV === \"production\" || invariant.warn(\"You're using fragments in your queries, but either don't have the addTypename:\\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\\n   can accurately match fragments.\");\n                process.env.NODE_ENV === \"production\" || invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);\n                process.env.NODE_ENV === \"production\" || invariant.warn(\"DEPRECATION WARNING: using fragments without __typename is unsupported behavior \" +\n                    \"and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.\");\n            }\n            return 'heuristic';\n        }\n        if (__typename === typeCondition) {\n            return true;\n        }\n        if (shouldWarn()) {\n            process.env.NODE_ENV === \"production\" || invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +\n                'queries contain union or interface types. Apollo Client will not be ' +\n                'able to accurately map fragments. To make this error go away, use ' +\n                'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n                'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');\n        }\n        return 'heuristic';\n    };\n    return HeuristicFragmentMatcher;\n}());\nvar IntrospectionFragmentMatcher = (function () {\n    function IntrospectionFragmentMatcher(options) {\n        if (options && options.introspectionQueryResultData) {\n            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);\n            this.isReady = true;\n        }\n        else {\n            this.isReady = false;\n        }\n        this.match = this.match.bind(this);\n    }\n    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {\n        process.env.NODE_ENV === \"production\" ? invariant(this.isReady, 6) : invariant(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');\n        var obj = context.store.get(idValue.id);\n        var isRootQuery = idValue.id === 'ROOT_QUERY';\n        if (!obj) {\n            return isRootQuery;\n        }\n        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && 'Query' : _a;\n        process.env.NODE_ENV === \"production\" ? invariant(__typename, 7) : invariant(__typename, \"Cannot match fragment because __typename property is missing: \" + JSON.stringify(obj));\n        if (__typename === typeCondition) {\n            return true;\n        }\n        var implementingTypes = this.possibleTypesMap[typeCondition];\n        if (__typename &&\n            implementingTypes &&\n            implementingTypes.indexOf(__typename) > -1) {\n            return true;\n        }\n        return false;\n    };\n    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {\n        var typeMap = {};\n        introspectionResultData.__schema.types.forEach(function (type) {\n            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });\n            }\n        });\n        return typeMap;\n    };\n    return IntrospectionFragmentMatcher;\n}());\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar DepTrackingCache = (function () {\n    function DepTrackingCache(data) {\n        var _this = this;\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n        this.depend = wrap(function (dataId) { return _this.data[dataId]; }, {\n            disposable: true,\n            makeCacheKey: function (dataId) {\n                return dataId;\n            },\n        });\n    }\n    DepTrackingCache.prototype.toObject = function () {\n        return this.data;\n    };\n    DepTrackingCache.prototype.get = function (dataId) {\n        this.depend(dataId);\n        return this.data[dataId];\n    };\n    DepTrackingCache.prototype.set = function (dataId, value) {\n        var oldValue = this.data[dataId];\n        if (value !== oldValue) {\n            this.data[dataId] = value;\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.delete = function (dataId) {\n        if (hasOwn.call(this.data, dataId)) {\n            delete this.data[dataId];\n            this.depend.dirty(dataId);\n        }\n    };\n    DepTrackingCache.prototype.clear = function () {\n        this.replace(null);\n    };\n    DepTrackingCache.prototype.replace = function (newData) {\n        var _this = this;\n        if (newData) {\n            Object.keys(newData).forEach(function (dataId) {\n                _this.set(dataId, newData[dataId]);\n            });\n            Object.keys(this.data).forEach(function (dataId) {\n                if (!hasOwn.call(newData, dataId)) {\n                    _this.delete(dataId);\n                }\n            });\n        }\n        else {\n            Object.keys(this.data).forEach(function (dataId) {\n                _this.delete(dataId);\n            });\n        }\n    };\n    return DepTrackingCache;\n}());\nfunction defaultNormalizedCacheFactory(seed) {\n    return new DepTrackingCache(seed);\n}\n\nvar StoreReader = (function () {\n    function StoreReader(_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;\n        var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;\n        this.freezeResults = freezeResults;\n        this.executeStoreQuery = wrap(function (options) {\n            return executeStoreQuery.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, fragmentMatcher = _a.fragmentMatcher;\n                if (contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSelectionSet = wrap(function (options) {\n            return executeSelectionSet.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);\n                }\n            }\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            return executeSubSelectedArray.call(_this, options);\n        }, {\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, execContext = _a.execContext;\n                if (execContext.contextValue.store instanceof DepTrackingCache) {\n                    return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));\n                }\n            }\n        });\n    }\n    StoreReader.prototype.readQueryFromStore = function (options) {\n        return this.diffQueryAgainstStore(__assign({}, options, { returnPartialData: false })).result;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? 'ROOT_QUERY' : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;\n        var queryDefinition = getQueryDefinition(query);\n        variables = assign({}, getDefaultValues(queryDefinition), variables);\n        var context = {\n            store: store,\n            dataIdFromObject: config && config.dataIdFromObject,\n            cacheRedirects: (config && config.cacheRedirects) || {},\n        };\n        var execResult = this.executeStoreQuery({\n            query: query,\n            rootValue: {\n                type: 'id',\n                id: rootId,\n                generated: true,\n                typename: 'Query',\n            },\n            contextValue: context,\n            variableValues: variables,\n            fragmentMatcher: fragmentMatcherFunction,\n        });\n        var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n        if (hasMissingFields && !returnPartialData) {\n            execResult.missing.forEach(function (info) {\n                if (info.tolerable)\n                    return;\n                throw process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError(\"Can't find field \" + info.fieldName + \" on object \" + JSON.stringify(info.object, null, 2) + \".\");\n            });\n        }\n        if (previousResult) {\n            if (isEqual(previousResult, execResult.result)) {\n                execResult.result = previousResult;\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !hasMissingFields,\n        };\n    };\n    StoreReader.prototype.executeStoreQuery = function (_a) {\n        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;\n        var mainDefinition = getMainDefinition(query);\n        var fragments = getFragmentDefinitions(query);\n        var fragmentMap = createFragmentMap(fragments);\n        var execContext = {\n            query: query,\n            fragmentMap: fragmentMap,\n            contextValue: contextValue,\n            variableValues: variableValues,\n            fragmentMatcher: fragmentMatcher,\n        };\n        return this.executeSelectionSet({\n            selectionSet: mainDefinition.selectionSet,\n            rootValue: rootValue,\n            execContext: execContext,\n        });\n    };\n    StoreReader.prototype.executeSelectionSet = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;\n        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;\n        var finalResult = { result: null };\n        var objectsToMerge = [];\n        var object = contextValue.store.get(rootValue.id);\n        var typename = (object && object.__typename) ||\n            (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n            void 0;\n        function handleMissing(result) {\n            var _a;\n            if (result.missing) {\n                finalResult.missing = finalResult.missing || [];\n                (_a = finalResult.missing).push.apply(_a, result.missing);\n            }\n            return result.result;\n        }\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));\n                if (typeof fieldResult !== 'undefined') {\n                    objectsToMerge.push((_a = {},\n                        _a[resultKeyNameFromField(selection)] = fieldResult,\n                        _a));\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = fragmentMap[selection.name.value];\n                    if (!fragment) {\n                        throw process.env.NODE_ENV === \"production\" ? new InvariantError(9) : new InvariantError(\"No fragment named \" + selection.name.value);\n                    }\n                }\n                var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;\n                var match = !typeCondition ||\n                    execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n                if (match) {\n                    var fragmentExecResult = _this.executeSelectionSet({\n                        selectionSet: fragment.selectionSet,\n                        rootValue: rootValue,\n                        execContext: execContext,\n                    });\n                    if (match === 'heuristic' && fragmentExecResult.missing) {\n                        fragmentExecResult = __assign({}, fragmentExecResult, { missing: fragmentExecResult.missing.map(function (info) {\n                                return __assign({}, info, { tolerable: true });\n                            }) });\n                    }\n                    objectsToMerge.push(handleMissing(fragmentExecResult));\n                }\n            }\n        });\n        finalResult.result = mergeDeepArray(objectsToMerge);\n        if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n            Object.freeze(finalResult.result);\n        }\n        return finalResult;\n    };\n    StoreReader.prototype.executeField = function (object, typename, field, execContext) {\n        var variables = execContext.variableValues, contextValue = execContext.contextValue;\n        var fieldName = field.name.value;\n        var args = argumentsObjectFromField(field, variables);\n        var info = {\n            resultKey: resultKeyNameFromField(field),\n            directives: getDirectiveInfoFromField(field, variables),\n        };\n        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);\n        if (Array.isArray(readStoreResult.result)) {\n            return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({\n                field: field,\n                array: readStoreResult.result,\n                execContext: execContext,\n            }));\n        }\n        if (!field.selectionSet) {\n            assertSelectionSetForIdValue(field, readStoreResult.result);\n            if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n                maybeDeepFreeze(readStoreResult);\n            }\n            return readStoreResult;\n        }\n        if (readStoreResult.result == null) {\n            return readStoreResult;\n        }\n        return this.combineExecResults(readStoreResult, this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            rootValue: readStoreResult.result,\n            execContext: execContext,\n        }));\n    };\n    StoreReader.prototype.combineExecResults = function () {\n        var execResults = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            execResults[_i] = arguments[_i];\n        }\n        var missing;\n        execResults.forEach(function (execResult) {\n            if (execResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, execResult.missing);\n            }\n        });\n        return {\n            result: execResults.pop().result,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.executeSubSelectedArray = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, execContext = _a.execContext;\n        var missing;\n        function handleMissing(childResult) {\n            if (childResult.missing) {\n                missing = missing || [];\n                missing.push.apply(missing, childResult.missing);\n            }\n            return childResult.result;\n        }\n        array = array.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    execContext: execContext,\n                }));\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    rootValue: item,\n                    execContext: execContext,\n                }));\n            }\n            assertSelectionSetForIdValue(field, item);\n            return item;\n        });\n        if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n            Object.freeze(array);\n        }\n        return { result: array, missing: missing };\n    };\n    return StoreReader;\n}());\nfunction assertSelectionSetForIdValue(field, value) {\n    if (!field.selectionSet && isIdValue(value)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(10) : new InvariantError(\"Missing selection set for object of type \" + value.typename + \" returned for query field \" + field.name.value);\n    }\n}\nfunction defaultFragmentMatcher() {\n    return true;\n}\nfunction assertIdValue(idValue) {\n    process.env.NODE_ENV === \"production\" ? invariant(isIdValue(idValue), 11) : invariant(isIdValue(idValue), \"Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.\");\n}\nfunction readStoreResolver(object, typename, fieldName, args, context, _a) {\n    var resultKey = _a.resultKey, directives = _a.directives;\n    var storeKeyName = fieldName;\n    if (args || directives) {\n        storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n    }\n    var fieldValue = void 0;\n    if (object) {\n        fieldValue = object[storeKeyName];\n        if (typeof fieldValue === 'undefined' &&\n            context.cacheRedirects &&\n            typeof typename === 'string') {\n            var type = context.cacheRedirects[typename];\n            if (type) {\n                var resolver = type[fieldName];\n                if (resolver) {\n                    fieldValue = resolver(object, args, {\n                        getCacheKey: function (storeObj) {\n                            var id = context.dataIdFromObject(storeObj);\n                            return id && toIdValue({\n                                id: id,\n                                typename: storeObj.__typename,\n                            });\n                        },\n                    });\n                }\n            }\n        }\n    }\n    if (typeof fieldValue === 'undefined') {\n        return {\n            result: fieldValue,\n            missing: [{\n                    object: object,\n                    fieldName: storeKeyName,\n                    tolerable: false,\n                }],\n        };\n    }\n    if (isJsonValue(fieldValue)) {\n        fieldValue = fieldValue.json;\n    }\n    return {\n        result: fieldValue,\n    };\n}\n\nvar ObjectCache = (function () {\n    function ObjectCache(data) {\n        if (data === void 0) { data = Object.create(null); }\n        this.data = data;\n    }\n    ObjectCache.prototype.toObject = function () {\n        return this.data;\n    };\n    ObjectCache.prototype.get = function (dataId) {\n        return this.data[dataId];\n    };\n    ObjectCache.prototype.set = function (dataId, value) {\n        this.data[dataId] = value;\n    };\n    ObjectCache.prototype.delete = function (dataId) {\n        this.data[dataId] = void 0;\n    };\n    ObjectCache.prototype.clear = function () {\n        this.data = Object.create(null);\n    };\n    ObjectCache.prototype.replace = function (newData) {\n        this.data = newData || Object.create(null);\n    };\n    return ObjectCache;\n}());\nfunction defaultNormalizedCacheFactory$1(seed) {\n    return new ObjectCache(seed);\n}\n\nvar WriteError = (function (_super) {\n    __extends(WriteError, _super);\n    function WriteError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = 'WriteError';\n        return _this;\n    }\n    return WriteError;\n}(Error));\nfunction enhanceErrorWithDocument(error, document) {\n    var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + JSON.stringify(document));\n    enhancedError.message += '\\n' + error.message;\n    enhancedError.stack = error.stack;\n    return enhancedError;\n}\nvar StoreWriter = (function () {\n    function StoreWriter() {\n    }\n    StoreWriter.prototype.writeQueryToStore = function (_a) {\n        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        return this.writeResultToStore({\n            dataId: 'ROOT_QUERY',\n            result: result,\n            document: query,\n            store: store,\n            variables: variables,\n            dataIdFromObject: dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n    };\n    StoreWriter.prototype.writeResultToStore = function (_a) {\n        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;\n        var operationDefinition = getOperationDefinition(document);\n        try {\n            return this.writeSelectionSetToStore({\n                result: result,\n                dataId: dataId,\n                selectionSet: operationDefinition.selectionSet,\n                context: {\n                    store: store,\n                    processedData: {},\n                    variables: assign({}, getDefaultValues(operationDefinition), variables),\n                    dataIdFromObject: dataIdFromObject,\n                    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n                    fragmentMatcherFunction: fragmentMatcherFunction,\n                },\n            });\n        }\n        catch (e) {\n            throw enhanceErrorWithDocument(e, document);\n        }\n    };\n    StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n        var _this = this;\n        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;\n        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;\n        selectionSet.selections.forEach(function (selection) {\n            var _a;\n            if (!shouldInclude(selection, variables)) {\n                return;\n            }\n            if (isField(selection)) {\n                var resultFieldKey = resultKeyNameFromField(selection);\n                var value = result[resultFieldKey];\n                if (typeof value !== 'undefined') {\n                    _this.writeFieldToStore({\n                        dataId: dataId,\n                        value: value,\n                        field: selection,\n                        context: context,\n                    });\n                }\n                else {\n                    var isDefered = false;\n                    var isClient = false;\n                    if (selection.directives && selection.directives.length) {\n                        isDefered = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'defer'; });\n                        isClient = selection.directives.some(function (directive) { return directive.name && directive.name.value === 'client'; });\n                    }\n                    if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n                        process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n                    }\n                }\n            }\n            else {\n                var fragment = void 0;\n                if (isInlineFragment(selection)) {\n                    fragment = selection;\n                }\n                else {\n                    fragment = (fragmentMap || {})[selection.name.value];\n                    process.env.NODE_ENV === \"production\" ? invariant(fragment, 2) : invariant(fragment, \"No fragment named \" + selection.name.value + \".\");\n                }\n                var matches = true;\n                if (context.fragmentMatcherFunction && fragment.typeCondition) {\n                    var id = dataId || 'self';\n                    var idValue = toIdValue({ id: id, typename: undefined });\n                    var fakeContext = {\n                        store: new ObjectCache((_a = {}, _a[id] = result, _a)),\n                        cacheRedirects: {},\n                    };\n                    var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n                    if (!isProduction() && match === 'heuristic') {\n                        process.env.NODE_ENV === \"production\" || invariant.error('WARNING: heuristic fragment matching going on!');\n                    }\n                    matches = !!match;\n                }\n                if (matches) {\n                    _this.writeSelectionSetToStore({\n                        result: result,\n                        selectionSet: fragment.selectionSet,\n                        dataId: dataId,\n                        context: context,\n                    });\n                }\n            }\n        });\n        return store;\n    };\n    StoreWriter.prototype.writeFieldToStore = function (_a) {\n        var _b;\n        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;\n        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;\n        var storeValue;\n        var storeObject;\n        var storeFieldName = storeKeyNameFromField(field, variables);\n        if (!field.selectionSet || value === null) {\n            storeValue =\n                value != null && typeof value === 'object'\n                    ?\n                        { type: 'json', json: value }\n                    :\n                        value;\n        }\n        else if (Array.isArray(value)) {\n            var generatedId = dataId + \".\" + storeFieldName;\n            storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);\n        }\n        else {\n            var valueDataId = dataId + \".\" + storeFieldName;\n            var generated = true;\n            if (!isGeneratedId(valueDataId)) {\n                valueDataId = '$' + valueDataId;\n            }\n            if (dataIdFromObject) {\n                var semanticId = dataIdFromObject(value);\n                process.env.NODE_ENV === \"production\" ? invariant(!semanticId || !isGeneratedId(semanticId), 3) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n                if (semanticId ||\n                    (typeof semanticId === 'number' && semanticId === 0)) {\n                    valueDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(valueDataId, field, context.processedData)) {\n                this.writeSelectionSetToStore({\n                    dataId: valueDataId,\n                    result: value,\n                    selectionSet: field.selectionSet,\n                    context: context,\n                });\n            }\n            var typename = value.__typename;\n            storeValue = toIdValue({ id: valueDataId, typename: typename }, generated);\n            storeObject = store.get(dataId);\n            var escapedId = storeObject && storeObject[storeFieldName];\n            if (escapedId !== storeValue && isIdValue(escapedId)) {\n                var hadTypename = escapedId.typename !== undefined;\n                var hasTypename = typename !== undefined;\n                var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;\n                process.env.NODE_ENV === \"production\" ? invariant(!generated || escapedId.generated || typenameChanged, 4) : invariant(!generated || escapedId.generated || typenameChanged, \"Store error: the application attempted to write an object with no provided id but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n                process.env.NODE_ENV === \"production\" ? invariant(!hadTypename || hasTypename, 5) : invariant(!hadTypename || hasTypename, \"Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet that was trying to be written is:\\n\" + JSON.stringify(field));\n                if (escapedId.generated) {\n                    if (typenameChanged) {\n                        if (!generated) {\n                            store.delete(escapedId.id);\n                        }\n                    }\n                    else {\n                        mergeWithGenerated(escapedId.id, storeValue.id, store);\n                    }\n                }\n            }\n        }\n        storeObject = store.get(dataId);\n        if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n            store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));\n        }\n    };\n    StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {\n        var _this = this;\n        return value.map(function (item, index) {\n            if (item === null) {\n                return null;\n            }\n            var itemDataId = generatedId + \".\" + index;\n            if (Array.isArray(item)) {\n                return _this.processArrayValue(item, itemDataId, selectionSet, context);\n            }\n            var generated = true;\n            if (context.dataIdFromObject) {\n                var semanticId = context.dataIdFromObject(item);\n                if (semanticId) {\n                    itemDataId = semanticId;\n                    generated = false;\n                }\n            }\n            if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n                _this.writeSelectionSetToStore({\n                    dataId: itemDataId,\n                    result: item,\n                    selectionSet: selectionSet,\n                    context: context,\n                });\n            }\n            return toIdValue({ id: itemDataId, typename: item.__typename }, generated);\n        });\n    };\n    return StoreWriter;\n}());\nfunction isGeneratedId(id) {\n    return id[0] === '$';\n}\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n    if (generatedKey === realKey) {\n        return false;\n    }\n    var generated = cache.get(generatedKey);\n    var real = cache.get(realKey);\n    var madeChanges = false;\n    Object.keys(generated).forEach(function (key) {\n        var value = generated[key];\n        var realValue = real[key];\n        if (isIdValue(value) &&\n            isGeneratedId(value.id) &&\n            isIdValue(realValue) &&\n            !isEqual(value, realValue) &&\n            mergeWithGenerated(value.id, realValue.id, cache)) {\n            madeChanges = true;\n        }\n    });\n    cache.delete(generatedKey);\n    var newRealValue = __assign({}, generated, real);\n    if (isEqual(newRealValue, real)) {\n        return madeChanges;\n    }\n    cache.set(realKey, newRealValue);\n    return true;\n}\nfunction isDataProcessed(dataId, field, processedData) {\n    if (!processedData) {\n        return false;\n    }\n    if (processedData[dataId]) {\n        if (processedData[dataId].indexOf(field) >= 0) {\n            return true;\n        }\n        else {\n            processedData[dataId].push(field);\n        }\n    }\n    else {\n        processedData[dataId] = [field];\n    }\n    return false;\n}\n\nvar defaultConfig = {\n    fragmentMatcher: new HeuristicFragmentMatcher(),\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    freezeResults: false,\n};\nfunction defaultDataIdFromObject(result) {\n    if (result.__typename) {\n        if (result.id !== undefined) {\n            return result.__typename + \":\" + result.id;\n        }\n        if (result._id !== undefined) {\n            return result.__typename + \":\" + result._id;\n        }\n    }\n    return null;\n}\nvar hasOwn$1 = Object.prototype.hasOwnProperty;\nvar OptimisticCacheLayer = (function (_super) {\n    __extends(OptimisticCacheLayer, _super);\n    function OptimisticCacheLayer(optimisticId, parent, transaction) {\n        var _this = _super.call(this, Object.create(null)) || this;\n        _this.optimisticId = optimisticId;\n        _this.parent = parent;\n        _this.transaction = transaction;\n        return _this;\n    }\n    OptimisticCacheLayer.prototype.toObject = function () {\n        return __assign({}, this.parent.toObject(), this.data);\n    };\n    OptimisticCacheLayer.prototype.get = function (dataId) {\n        return hasOwn$1.call(this.data, dataId)\n            ? this.data[dataId]\n            : this.parent.get(dataId);\n    };\n    return OptimisticCacheLayer;\n}(ObjectCache));\nvar InMemoryCache = (function (_super) {\n    __extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.typenameDocumentCache = new Map();\n        _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);\n        _this.silenceBroadcast = false;\n        _this.config = __assign({}, defaultConfig, config);\n        if (_this.config.customResolvers) {\n            process.env.NODE_ENV === \"production\" || invariant.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.customResolvers;\n        }\n        if (_this.config.cacheResolvers) {\n            process.env.NODE_ENV === \"production\" || invariant.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');\n            _this.config.cacheRedirects = _this.config.cacheResolvers;\n        }\n        _this.addTypename = !!_this.config.addTypename;\n        _this.data = _this.config.resultCaching\n            ? new DepTrackingCache()\n            : new ObjectCache();\n        _this.optimisticData = _this.data;\n        _this.storeWriter = new StoreWriter();\n        _this.storeReader = new StoreReader({\n            cacheKeyRoot: _this.cacheKeyRoot,\n            freezeResults: config.freezeResults,\n        });\n        var cache = _this;\n        var maybeBroadcastWatch = cache.maybeBroadcastWatch;\n        _this.maybeBroadcastWatch = wrap(function (c) {\n            return maybeBroadcastWatch.call(_this, c);\n        }, {\n            makeCacheKey: function (c) {\n                if (c.optimistic) {\n                    return;\n                }\n                if (c.previousResult) {\n                    return;\n                }\n                if (cache.data instanceof DepTrackingCache) {\n                    return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));\n                }\n            }\n        });\n        return _this;\n    }\n    InMemoryCache.prototype.restore = function (data) {\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).toObject();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        if (typeof options.rootId === 'string' &&\n            typeof this.data.get(options.rootId) === 'undefined') {\n            return null;\n        }\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.readQueryFromStore({\n            store: options.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(options.query),\n            variables: options.variables,\n            rootId: options.rootId,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            previousResult: options.previousResult,\n            config: this.config,\n        }) || null;\n    };\n    InMemoryCache.prototype.write = function (write) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        this.storeWriter.writeResultToStore({\n            dataId: write.dataId,\n            result: write.result,\n            variables: write.variables,\n            document: this.transformDocument(write.query),\n            store: this.data,\n            dataIdFromObject: this.config.dataIdFromObject,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n        });\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.diff = function (query) {\n        var fragmentMatcher = this.config.fragmentMatcher;\n        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n        return this.storeReader.diffQueryAgainstStore({\n            store: query.optimistic ? this.optimisticData : this.data,\n            query: this.transformDocument(query.query),\n            variables: query.variables,\n            returnPartialData: query.returnPartialData,\n            previousResult: query.previousResult,\n            fragmentMatcherFunction: fragmentMatcherFunction,\n            config: this.config,\n        });\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        this.watches.add(watch);\n        return function () {\n            _this.watches.delete(watch);\n        };\n    };\n    InMemoryCache.prototype.evict = function (query) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(1) : new InvariantError(\"eviction is not implemented on InMemory Cache\");\n    };\n    InMemoryCache.prototype.reset = function () {\n        this.data.clear();\n        this.broadcastWatches();\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var toReapply = [];\n        var removedCount = 0;\n        var layer = this.optimisticData;\n        while (layer instanceof OptimisticCacheLayer) {\n            if (layer.optimisticId === idToRemove) {\n                ++removedCount;\n            }\n            else {\n                toReapply.push(layer);\n            }\n            layer = layer.parent;\n        }\n        if (removedCount > 0) {\n            this.optimisticData = layer;\n            while (toReapply.length > 0) {\n                var layer_1 = toReapply.pop();\n                this.performTransaction(layer_1.transaction, layer_1.optimisticId);\n            }\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;\n        this.silenceBroadcast = true;\n        if (typeof optimisticId === 'string') {\n            this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);\n        }\n        try {\n            transaction(this);\n        }\n        finally {\n            this.silenceBroadcast = silenceBroadcast;\n            this.data = data;\n        }\n        this.broadcastWatches();\n    };\n    InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {\n        return this.performTransaction(transaction, id);\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        if (this.addTypename) {\n            var result = this.typenameDocumentCache.get(document);\n            if (!result) {\n                result = addTypenameToDocument(document);\n                this.typenameDocumentCache.set(document, result);\n                this.typenameDocumentCache.set(result, result);\n            }\n            return result;\n        }\n        return document;\n    };\n    InMemoryCache.prototype.broadcastWatches = function () {\n        var _this = this;\n        if (!this.silenceBroadcast) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c); });\n        }\n    };\n    InMemoryCache.prototype.maybeBroadcastWatch = function (c) {\n        c.callback(this.diff({\n            query: c.query,\n            variables: c.variables,\n            previousResult: c.previousResult && c.previousResult(),\n            optimistic: c.optimistic,\n        }));\n    };\n    return InMemoryCache;\n}(ApolloCache));\n\nexport { HeuristicFragmentMatcher, InMemoryCache, IntrospectionFragmentMatcher, ObjectCache, StoreReader, StoreWriter, WriteError, assertIdValue, defaultDataIdFromObject, defaultNormalizedCacheFactory$1 as defaultNormalizedCacheFactory, enhanceErrorWithDocument };\n//# sourceMappingURL=bundle.esm.js.map\n"],"sourceRoot":""}