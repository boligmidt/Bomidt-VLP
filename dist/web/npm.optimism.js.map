{"version":3,"sources":["webpack:///./node_modules/optimism/lib/bundle.esm.js"],"names":["defaultDispose","Cache","max","dispose","Infinity","this","map","Map","newest","oldest","prototype","has","key","get","entry","getEntry","value","older","newer","set","clean","size","delete","parentEntrySlot","reusableEmptyArray","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","valueGet","length","Entry","fn","args","parents","Set","childValues","dirtyChildren","dirty","recomputing","count","recompute","child","parent","getValue","add","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","withValue","recomputeNewValue","subscribe","maybeUnsubscribe","unsubscribe","apply","e","setDirty","maybeSubscribe","reportClean","setClean","forEach","reallyRecompute","reportDirty","_this","forgetChild","pop","a","b","len","childValue","slice","removeDirtyChild","dc","push","reportOrphan","children","_value","KeyTrie","weakness","lookup","array","_i","arguments","lookupArray","node","getChildTrie","data","Object","create","isObjRef","weak","WeakMap","strong","keyTrie","defaultMakeCacheKey","caches","wrap","originalFunction","options","cache","Math","pow","disposable","makeCacheKey","optimistic","hasValue","Array","call","clear"],"mappings":"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","file":"npm.optimism.js","sourcesContent":["import { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() { }\r\nvar Cache = /** @class */ (function () {\r\n    function Cache(max, dispose) {\r\n        if (max === void 0) { max = Infinity; }\r\n        if (dispose === void 0) { dispose = defaultDispose; }\r\n        this.max = max;\r\n        this.dispose = dispose;\r\n        this.map = new Map();\r\n        this.newest = null;\r\n        this.oldest = null;\r\n    }\r\n    Cache.prototype.has = function (key) {\r\n        return this.map.has(key);\r\n    };\r\n    Cache.prototype.get = function (key) {\r\n        var entry = this.getEntry(key);\r\n        return entry && entry.value;\r\n    };\r\n    Cache.prototype.getEntry = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry && entry !== this.newest) {\r\n            var older = entry.older, newer = entry.newer;\r\n            if (newer) {\r\n                newer.older = older;\r\n            }\r\n            if (older) {\r\n                older.newer = newer;\r\n            }\r\n            entry.older = this.newest;\r\n            entry.older.newer = entry;\r\n            entry.newer = null;\r\n            this.newest = entry;\r\n            if (entry === this.oldest) {\r\n                this.oldest = newer;\r\n            }\r\n        }\r\n        return entry;\r\n    };\r\n    Cache.prototype.set = function (key, value) {\r\n        var entry = this.getEntry(key);\r\n        if (entry) {\r\n            return entry.value = value;\r\n        }\r\n        entry = {\r\n            key: key,\r\n            value: value,\r\n            newer: null,\r\n            older: this.newest\r\n        };\r\n        if (this.newest) {\r\n            this.newest.newer = entry;\r\n        }\r\n        this.newest = entry;\r\n        this.oldest = this.oldest || entry;\r\n        this.map.set(key, entry);\r\n        return entry.value;\r\n    };\r\n    Cache.prototype.clean = function () {\r\n        while (this.oldest && this.map.size > this.max) {\r\n            this.delete(this.oldest.key);\r\n        }\r\n    };\r\n    Cache.prototype.delete = function (key) {\r\n        var entry = this.map.get(key);\r\n        if (entry) {\r\n            if (entry === this.newest) {\r\n                this.newest = entry.older;\r\n            }\r\n            if (entry === this.oldest) {\r\n                this.oldest = entry.newer;\r\n            }\r\n            if (entry.newer) {\r\n                entry.newer.older = entry.older;\r\n            }\r\n            if (entry.older) {\r\n                entry.older.newer = entry.newer;\r\n            }\r\n            this.map.delete(key);\r\n            this.dispose(entry.value, key);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    return Cache;\r\n}());\n\nvar parentEntrySlot = new Slot();\n\nvar reusableEmptyArray = [];\r\nvar emptySetPool = [];\r\nvar POOL_TARGET_SIZE = 100;\r\n// Since this package might be used browsers, we should avoid using the\r\n// Node built-in assert module.\r\nfunction assert(condition, optionalMessage) {\r\n    if (!condition) {\r\n        throw new Error(optionalMessage || \"assertion failure\");\r\n    }\r\n}\r\nfunction valueIs(a, b) {\r\n    var len = a.length;\r\n    return (\r\n    // Unknown values are not equal to each other.\r\n    len > 0 &&\r\n        // Both values must be ordinary (or both exceptional) to be equal.\r\n        len === b.length &&\r\n        // The underlying value or exception must be the same.\r\n        a[len - 1] === b[len - 1]);\r\n}\r\nfunction valueGet(value) {\r\n    switch (value.length) {\r\n        case 0: throw new Error(\"unknown value\");\r\n        case 1: return value[0];\r\n        case 2: throw value[1];\r\n    }\r\n}\r\nfunction valueCopy(value) {\r\n    return value.slice(0);\r\n}\r\nvar Entry = /** @class */ (function () {\r\n    function Entry(fn, args) {\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.parents = new Set();\r\n        this.childValues = new Map();\r\n        // When this Entry has children that are dirty, this property becomes\r\n        // a Set containing other Entry objects, borrowed from emptySetPool.\r\n        // When the set becomes empty, it gets recycled back to emptySetPool.\r\n        this.dirtyChildren = null;\r\n        this.dirty = true;\r\n        this.recomputing = false;\r\n        this.value = [];\r\n        ++Entry.count;\r\n    }\r\n    // This is the most important method of the Entry API, because it\r\n    // determines whether the cached this.value can be returned immediately,\r\n    // or must be recomputed. The overall performance of the caching system\r\n    // depends on the truth of the following observations: (1) this.dirty is\r\n    // usually false, (2) this.dirtyChildren is usually null/empty, and thus\r\n    // (3) valueGet(this.value) is usually returned without recomputation.\r\n    Entry.prototype.recompute = function () {\r\n        assert(!this.recomputing, \"already recomputing\");\r\n        if (!rememberParent(this) && maybeReportOrphan(this)) {\r\n            // The recipient of the entry.reportOrphan callback decided to dispose\r\n            // of this orphan entry by calling entry.dispose(), so we don't need to\r\n            // (and should not) proceed with the recomputation.\r\n            return void 0;\r\n        }\r\n        return mightBeDirty(this)\r\n            ? reallyRecompute(this)\r\n            : valueGet(this.value);\r\n    };\r\n    Entry.prototype.setDirty = function () {\r\n        if (this.dirty)\r\n            return;\r\n        this.dirty = true;\r\n        this.value.length = 0;\r\n        reportDirty(this);\r\n        // We can go ahead and unsubscribe here, since any further dirty\r\n        // notifications we receive will be redundant, and unsubscribing may\r\n        // free up some resources, e.g. file watchers.\r\n        maybeUnsubscribe(this);\r\n    };\r\n    Entry.prototype.dispose = function () {\r\n        var _this = this;\r\n        forgetChildren(this).forEach(maybeReportOrphan);\r\n        maybeUnsubscribe(this);\r\n        // Because this entry has been kicked out of the cache (in index.js),\r\n        // we've lost the ability to find out if/when this entry becomes dirty,\r\n        // whether that happens through a subscription, because of a direct call\r\n        // to entry.setDirty(), or because one of its children becomes dirty.\r\n        // Because of this loss of future information, we have to assume the\r\n        // worst (that this entry might have become dirty very soon), so we must\r\n        // immediately mark this entry's parents as dirty. Normally we could\r\n        // just call entry.setDirty() rather than calling parent.setDirty() for\r\n        // each parent, but that would leave this entry in parent.childValues\r\n        // and parent.dirtyChildren, which would prevent the child from being\r\n        // truly forgotten.\r\n        this.parents.forEach(function (parent) {\r\n            parent.setDirty();\r\n            forgetChild(parent, _this);\r\n        });\r\n    };\r\n    Entry.count = 0;\r\n    return Entry;\r\n}());\r\nfunction rememberParent(child) {\r\n    var parent = parentEntrySlot.getValue();\r\n    if (parent) {\r\n        child.parents.add(parent);\r\n        if (!parent.childValues.has(child)) {\r\n            parent.childValues.set(child, []);\r\n        }\r\n        if (mightBeDirty(child)) {\r\n            reportDirtyChild(parent, child);\r\n        }\r\n        else {\r\n            reportCleanChild(parent, child);\r\n        }\r\n        return parent;\r\n    }\r\n}\r\nfunction reallyRecompute(entry) {\r\n    // Since this recomputation is likely to re-remember some of this\r\n    // entry's children, we forget our children here but do not call\r\n    // maybeReportOrphan until after the recomputation finishes.\r\n    var originalChildren = forgetChildren(entry);\r\n    // Set entry as the parent entry while calling recomputeNewValue(entry).\r\n    parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\r\n    if (maybeSubscribe(entry)) {\r\n        // If we successfully recomputed entry.value and did not fail to\r\n        // (re)subscribe, then this Entry is no longer explicitly dirty.\r\n        setClean(entry);\r\n    }\r\n    // Now that we've had a chance to re-remember any children that were\r\n    // involved in the recomputation, we can safely report any orphan\r\n    // children that remain.\r\n    originalChildren.forEach(maybeReportOrphan);\r\n    return valueGet(entry.value);\r\n}\r\nfunction recomputeNewValue(entry) {\r\n    entry.recomputing = true;\r\n    // Set entry.value as unknown.\r\n    entry.value.length = 0;\r\n    try {\r\n        // If entry.fn succeeds, entry.value will become a normal Value.\r\n        entry.value[0] = entry.fn.apply(null, entry.args);\r\n    }\r\n    catch (e) {\r\n        // If entry.fn throws, entry.value will become exceptional.\r\n        entry.value[1] = e;\r\n    }\r\n    // Either way, this line is always reached.\r\n    entry.recomputing = false;\r\n}\r\nfunction mightBeDirty(entry) {\r\n    return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\r\n}\r\nfunction setClean(entry) {\r\n    entry.dirty = false;\r\n    if (mightBeDirty(entry)) {\r\n        // This Entry may still have dirty children, in which case we can't\r\n        // let our parents know we're clean just yet.\r\n        return;\r\n    }\r\n    reportClean(entry);\r\n}\r\nfunction reportDirty(child) {\r\n    child.parents.forEach(function (parent) { return reportDirtyChild(parent, child); });\r\n}\r\nfunction reportClean(child) {\r\n    child.parents.forEach(function (parent) { return reportCleanChild(parent, child); });\r\n}\r\n// Let a parent Entry know that one of its children may be dirty.\r\nfunction reportDirtyChild(parent, child) {\r\n    // Must have called rememberParent(child) before calling\r\n    // reportDirtyChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(mightBeDirty(child));\r\n    if (!parent.dirtyChildren) {\r\n        parent.dirtyChildren = emptySetPool.pop() || new Set;\r\n    }\r\n    else if (parent.dirtyChildren.has(child)) {\r\n        // If we already know this child is dirty, then we must have already\r\n        // informed our own parents that we are dirty, so we can terminate\r\n        // the recursion early.\r\n        return;\r\n    }\r\n    parent.dirtyChildren.add(child);\r\n    reportDirty(parent);\r\n}\r\n// Let a parent Entry know that one of its children is no longer dirty.\r\nfunction reportCleanChild(parent, child) {\r\n    // Must have called rememberChild(child) before calling\r\n    // reportCleanChild(parent, child).\r\n    assert(parent.childValues.has(child));\r\n    assert(!mightBeDirty(child));\r\n    var childValue = parent.childValues.get(child);\r\n    if (childValue.length === 0) {\r\n        parent.childValues.set(child, valueCopy(child.value));\r\n    }\r\n    else if (!valueIs(childValue, child.value)) {\r\n        parent.setDirty();\r\n    }\r\n    removeDirtyChild(parent, child);\r\n    if (mightBeDirty(parent)) {\r\n        return;\r\n    }\r\n    reportClean(parent);\r\n}\r\nfunction removeDirtyChild(parent, child) {\r\n    var dc = parent.dirtyChildren;\r\n    if (dc) {\r\n        dc.delete(child);\r\n        if (dc.size === 0) {\r\n            if (emptySetPool.length < POOL_TARGET_SIZE) {\r\n                emptySetPool.push(dc);\r\n            }\r\n            parent.dirtyChildren = null;\r\n        }\r\n    }\r\n}\r\n// If the given entry has a reportOrphan method, and no remaining parents,\r\n// call entry.reportOrphan and return true iff it returns true. The\r\n// reportOrphan function should return true to indicate entry.dispose()\r\n// has been called, and the entry has been removed from any other caches\r\n// (see index.js for the only current example).\r\nfunction maybeReportOrphan(entry) {\r\n    return entry.parents.size === 0 &&\r\n        typeof entry.reportOrphan === \"function\" &&\r\n        entry.reportOrphan() === true;\r\n}\r\n// Removes all children from this entry and returns an array of the\r\n// removed children.\r\nfunction forgetChildren(parent) {\r\n    var children = reusableEmptyArray;\r\n    if (parent.childValues.size > 0) {\r\n        children = [];\r\n        parent.childValues.forEach(function (_value, child) {\r\n            forgetChild(parent, child);\r\n            children.push(child);\r\n        });\r\n    }\r\n    // After we forget all our children, this.dirtyChildren must be empty\r\n    // and therefore must have been reset to null.\r\n    assert(parent.dirtyChildren === null);\r\n    return children;\r\n}\r\nfunction forgetChild(parent, child) {\r\n    child.parents.delete(parent);\r\n    parent.childValues.delete(child);\r\n    removeDirtyChild(parent, child);\r\n}\r\nfunction maybeSubscribe(entry) {\r\n    if (typeof entry.subscribe === \"function\") {\r\n        try {\r\n            maybeUnsubscribe(entry); // Prevent double subscriptions.\r\n            entry.unsubscribe = entry.subscribe.apply(null, entry.args);\r\n        }\r\n        catch (e) {\r\n            // If this Entry has a subscribe function and it threw an exception\r\n            // (or an unsubscribe function it previously returned now throws),\r\n            // return false to indicate that we were not able to subscribe (or\r\n            // unsubscribe), and this Entry should remain dirty.\r\n            entry.setDirty();\r\n            return false;\r\n        }\r\n    }\r\n    // Returning true indicates either that there was no entry.subscribe\r\n    // function or that it succeeded.\r\n    return true;\r\n}\r\nfunction maybeUnsubscribe(entry) {\r\n    var unsubscribe = entry.unsubscribe;\r\n    if (typeof unsubscribe === \"function\") {\r\n        entry.unsubscribe = void 0;\r\n        unsubscribe();\r\n    }\r\n}\n\n// A trie data structure that holds object keys weakly, yet can also hold\r\n// non-object keys, unlike the native `WeakMap`.\r\nvar KeyTrie = /** @class */ (function () {\r\n    function KeyTrie(weakness) {\r\n        this.weakness = weakness;\r\n    }\r\n    KeyTrie.prototype.lookup = function () {\r\n        var array = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            array[_i] = arguments[_i];\r\n        }\r\n        return this.lookupArray(array);\r\n    };\r\n    KeyTrie.prototype.lookupArray = function (array) {\r\n        var node = this;\r\n        array.forEach(function (key) { return node = node.getChildTrie(key); });\r\n        return node.data || (node.data = Object.create(null));\r\n    };\r\n    KeyTrie.prototype.getChildTrie = function (key) {\r\n        var map = this.weakness && isObjRef(key)\r\n            ? this.weak || (this.weak = new WeakMap())\r\n            : this.strong || (this.strong = new Map());\r\n        var child = map.get(key);\r\n        if (!child)\r\n            map.set(key, child = new KeyTrie(this.weakness));\r\n        return child;\r\n    };\r\n    return KeyTrie;\r\n}());\r\nfunction isObjRef(value) {\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value === null)\r\n                break;\r\n        // Fall through to return true...\r\n        case \"function\":\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\r\n// a unique object for any shallow-identical list of arguments. If you need\r\n// to implement a custom makeCacheKey function, you may find it helpful to\r\n// delegate the final work to defaultMakeCacheKey, which is why we export it\r\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\r\n// does not support WeakMap, or you have the ability to return a string key.\r\n// In those cases, just write your own custom makeCacheKey functions.\r\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\r\nfunction defaultMakeCacheKey() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return keyTrie.lookupArray(args);\r\n}\r\nvar caches = new Set();\r\nfunction wrap(originalFunction, options) {\r\n    if (options === void 0) { options = Object.create(null); }\r\n    var cache = new Cache(options.max || Math.pow(2, 16), function (entry) { return entry.dispose(); });\r\n    var disposable = !!options.disposable;\r\n    var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\r\n    function optimistic() {\r\n        if (disposable && !parentEntrySlot.hasValue()) {\r\n            // If there's no current parent computation, and this wrapped\r\n            // function is disposable (meaning we don't care about entry.value,\r\n            // just dependency tracking), then we can short-cut everything else\r\n            // in this function, because entry.recompute() is going to recycle\r\n            // the entry object without recomputing anything, anyway.\r\n            return void 0;\r\n        }\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        if (key === void 0) {\r\n            return originalFunction.apply(null, arguments);\r\n        }\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var entry = cache.get(key);\r\n        if (entry) {\r\n            entry.args = args;\r\n        }\r\n        else {\r\n            entry = new Entry(originalFunction, args);\r\n            cache.set(key, entry);\r\n            entry.subscribe = options.subscribe;\r\n            if (disposable) {\r\n                entry.reportOrphan = function () { return cache.delete(key); };\r\n            }\r\n        }\r\n        var value = entry.recompute();\r\n        // Move this entry to the front of the least-recently used queue,\r\n        // since we just finished computing its value.\r\n        cache.set(key, entry);\r\n        caches.add(cache);\r\n        // Clean up any excess entries in the cache, but only if there is no\r\n        // active parent entry, meaning we're not in the middle of a larger\r\n        // computation that might be flummoxed by the cleaning.\r\n        if (!parentEntrySlot.hasValue()) {\r\n            caches.forEach(function (cache) { return cache.clean(); });\r\n            caches.clear();\r\n        }\r\n        // If options.disposable is truthy, the caller of wrap is telling us\r\n        // they don't care about the result of entry.recompute(), so we should\r\n        // avoid returning the value, so it won't be accidentally used.\r\n        return disposable ? void 0 : value;\r\n    }\r\n    optimistic.dirty = function () {\r\n        var key = makeCacheKey.apply(null, arguments);\r\n        var child = key !== void 0 && cache.get(key);\r\n        if (child) {\r\n            child.setDirty();\r\n        }\r\n    };\r\n    return optimistic;\r\n}\n\nexport { KeyTrie, defaultMakeCacheKey, wrap };\n//# sourceMappingURL=bundle.esm.js.map\n"],"sourceRoot":""}