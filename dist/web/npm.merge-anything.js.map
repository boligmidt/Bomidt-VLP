{"version":3,"sources":["webpack:///./node_modules/merge-anything/dist/index.esm.js"],"names":["assignProp","carry","key","newVal","originalObject","propType","propertyIsEnumerable","Object","defineProperty","value","enumerable","writable","configurable","origin","newComers","_i","arguments","length","extensions","base","keys","reduce","result","newComer","mergeRecursively","forEach","extend","newObject","props_1","getOwnPropertyNames","symbols_1","getOwnPropertySymbols","concat","targetVal","includes","props","symbols","undefined"],"mappings":"2FAAA,YAEA,SAASA,EAAWC,EAAOC,EAAKC,EAAQC,GACpC,IAAIC,EAAWD,EAAeE,qBAAqBJ,GAC7C,aACA,gBACW,eAAbG,IACAJ,EAAMC,GAAOC,GACA,kBAAbE,GACAE,OAAOC,eAAeP,EAAOC,EAAK,CAC9BO,MAAON,EACPO,YAAY,EACZC,UAAU,EACVC,cAAc,IAuFX,IAxBf,SAAeC,GAEX,IADA,IAAIC,EAAY,GACPC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAUC,EAAK,GAAKC,UAAUD,GAElC,IAAIG,EAAa,KACbC,EAAON,EAKX,OAJI,YAAcA,IAAWA,EAAOK,YAA6C,IAA/BX,OAAOa,KAAKP,GAAQI,SAClEE,EAAO,GACPD,EAAaL,EAAOK,YAEjBJ,EAAUO,QAAO,SAAUC,EAAQC,GACtC,OAvER,SAASC,EAAiBX,EAAQU,EAAUL,GAExC,IAAK,YAAcK,GAOf,OALIL,GAAc,YAAQA,IACtBA,EAAWO,SAAQ,SAAUC,GACzBH,EAAWG,EAAOb,EAAQU,MAG3BA,EAGX,IAAII,EAAY,GAChB,GAAI,YAAcd,GAAS,CACvB,IAAIe,EAAUrB,OAAOsB,oBAAoBhB,GACrCiB,EAAYvB,OAAOwB,sBAAsBlB,GAC7Cc,EAAYC,EAAQI,OAAOF,GAAWT,QAAO,SAAUpB,EAAOC,GAE1D,IAAI+B,EAAYpB,EAAOX,GAKvB,QAJM,YAASA,KAASK,OAAOsB,oBAAoBN,GAAUW,SAAShC,IACjE,YAASA,KAASK,OAAOwB,sBAAsBR,GAAUW,SAAShC,KACnEF,EAAWC,EAAOC,EAAK+B,EAAWpB,GAE/BZ,IACR,IAEP,IAAIkC,EAAQ5B,OAAOsB,oBAAoBN,GACnCa,EAAU7B,OAAOwB,sBAAsBR,GAqB3C,OApBaY,EAAMH,OAAOI,GAASf,QAAO,SAAUpB,EAAOC,GAEvD,IAAIC,EAASoB,EAASrB,GAClB+B,EAAa,WAAD,CAAepB,GAEzBA,EAAOX,QACPmC,EAYN,OAVInB,GAAc,YAAQA,IACtBA,EAAWO,SAAQ,SAAUC,GACzBvB,EAASuB,EAAOO,EAAW9B,WAIjBkC,IAAdJ,GAA2B,YAAc9B,KACzCA,EAASqB,EAAiBS,EAAW9B,EAAQe,IAEjDlB,EAAWC,EAAOC,EAAKC,EAAQoB,GACxBtB,IACR0B,GAwBQH,CAAiBF,EAAQC,EAAUL,KAC3CC","file":"npm.merge-anything.js","sourcesContent":["import { isArray, isPlainObject, isSymbol } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject) {\r\n    var propType = originalObject.propertyIsEnumerable(key)\r\n        ? 'enumerable'\r\n        : 'nonenumerable';\r\n    if (propType === 'enumerable')\r\n        carry[key] = newVal;\r\n    if (propType === 'nonenumerable') {\r\n        Object.defineProperty(carry, key, {\r\n            value: newVal,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n}\r\nfunction mergeRecursively(origin, newComer, extensions) {\r\n    // work directly on newComer if its not an object\r\n    if (!isPlainObject(newComer)) {\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newComer = extend(origin, newComer);\r\n            });\r\n        }\r\n        return newComer;\r\n    }\r\n    // define newObject to merge all values upon\r\n    var newObject = {};\r\n    if (isPlainObject(origin)) {\r\n        var props_1 = Object.getOwnPropertyNames(origin);\r\n        var symbols_1 = Object.getOwnPropertySymbols(origin);\r\n        newObject = props_1.concat(symbols_1).reduce(function (carry, key) {\r\n            // @ts-ignore\r\n            var targetVal = origin[key];\r\n            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||\r\n                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {\r\n                assignProp(carry, key, targetVal, origin);\r\n            }\r\n            return carry;\r\n        }, {});\r\n    }\r\n    var props = Object.getOwnPropertyNames(newComer);\r\n    var symbols = Object.getOwnPropertySymbols(newComer);\r\n    var result = props.concat(symbols).reduce(function (carry, key) {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        var newVal = newComer[key];\r\n        var targetVal = (isPlainObject(origin))\r\n            // @ts-ignore\r\n            ? origin[key]\r\n            : undefined;\r\n        // extend merge rules\r\n        if (extensions && isArray(extensions)) {\r\n            extensions.forEach(function (extend) {\r\n                newVal = extend(targetVal, newVal);\r\n            });\r\n        }\r\n        // When newVal is an object do the merge recursively\r\n        if (targetVal !== undefined && isPlainObject(newVal)) {\r\n            newVal = mergeRecursively(targetVal, newVal, extensions);\r\n        }\r\n        assignProp(carry, key, newVal, newComer);\r\n        return carry;\r\n    }, newObject);\r\n    return result;\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n *\r\n * @param {(IConfig | any)} origin\r\n * @param {...any[]} newComers\r\n * @returns the result\r\n */\r\nfunction merge(origin) {\r\n    var newComers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        newComers[_i - 1] = arguments[_i];\r\n    }\r\n    var extensions = null;\r\n    var base = origin;\r\n    if (isPlainObject(origin) && origin.extensions && Object.keys(origin).length === 1) {\r\n        base = {};\r\n        extensions = origin.extensions;\r\n    }\r\n    return newComers.reduce(function (result, newComer) {\r\n        return mergeRecursively(result, newComer, extensions);\r\n    }, base);\r\n}\n\nfunction concatArrays(originVal, newVal) {\r\n    if (isArray(originVal) && isArray(newVal)) {\r\n        // concat logic\r\n        return originVal.concat(newVal);\r\n    }\r\n    return newVal; // always return newVal as fallback!!\r\n}\n\nexport default merge;\nexport { merge, concatArrays };\n"],"sourceRoot":""}